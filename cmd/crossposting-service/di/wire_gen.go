// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package di

import (
	"context"
	"database/sql"
	"github.com/ThreeDotsLabs/watermill"
	"github.com/google/wire"
	"github.com/planetary-social/nos-crossposting-service/internal/fixtures"
	"github.com/planetary-social/nos-crossposting-service/internal/logging"
	"github.com/planetary-social/nos-crossposting-service/service/adapters"
	"github.com/planetary-social/nos-crossposting-service/service/adapters/memorypubsub"
	"github.com/planetary-social/nos-crossposting-service/service/adapters/prometheus"
	"github.com/planetary-social/nos-crossposting-service/service/adapters/sqlite"
	"github.com/planetary-social/nos-crossposting-service/service/adapters/twitter"
	"github.com/planetary-social/nos-crossposting-service/service/app"
	"github.com/planetary-social/nos-crossposting-service/service/config"
	"github.com/planetary-social/nos-crossposting-service/service/domain"
	"github.com/planetary-social/nos-crossposting-service/service/ports/http"
	"github.com/planetary-social/nos-crossposting-service/service/ports/http/frontend"
	memorypubsub2 "github.com/planetary-social/nos-crossposting-service/service/ports/memorypubsub"
	"github.com/planetary-social/nos-crossposting-service/service/ports/sqlitepubsub"
	"testing"
)

// Injectors from wire.go:

func BuildService(contextContext context.Context, configConfig config.Config) (Service, func(), error) {
	logger, err := newLogger(configConfig)
	if err != nil {
		return Service{}, nil, err
	}
	db, cleanup, err := newSqliteDB(configConfig, logger)
	if err != nil {
		return Service{}, nil, err
	}
	watermillAdapter := logging.NewWatermillAdapter(logger)
	diBuildTransactionSqliteAdaptersDependencies := buildTransactionSqliteAdaptersDependencies{
		LoggerAdapter: watermillAdapter,
	}
	genericAdaptersFactoryFn := newAdaptersFactoryFn(diBuildTransactionSqliteAdaptersDependencies)
	genericTransactionProvider := sqlite.NewTransactionProvider(db, genericAdaptersFactoryFn)
	prometheusPrometheus, err := prometheus.NewPrometheus(logger)
	if err != nil {
		cleanup()
		return Service{}, nil, err
	}
	getSessionAccountHandler := app.NewGetSessionAccountHandler(genericTransactionProvider, logger, prometheusPrometheus)
	getAccountPublicKeysHandler := app.NewGetAccountPublicKeysHandler(genericTransactionProvider, logger, prometheusPrometheus)
	twitterTwitter := twitter.NewTwitter(configConfig, logger, prometheusPrometheus)
	developmentTwitter := twitter.NewDevelopmentTwitter(logger)
	appTwitter := selectTwitterAdapterDependingOnConfig(configConfig, twitterTwitter, developmentTwitter)
	twitterAccountDetailsCache := adapters.NewTwitterAccountDetailsCache()
	getTwitterAccountDetailsHandler := app.NewGetTwitterAccountDetailsHandler(genericTransactionProvider, appTwitter, twitterAccountDetailsCache, logger, prometheusPrometheus)
	idGenerator := adapters.NewIDGenerator()
	loginOrRegisterHandler := app.NewLoginOrRegisterHandler(genericTransactionProvider, idGenerator, idGenerator, logger, prometheusPrometheus)
	logoutHandler := app.NewLogoutHandler(genericTransactionProvider, logger, prometheusPrometheus)
	linkPublicKeyHandler := app.NewLinkPublicKeyHandler(genericTransactionProvider, logger, prometheusPrometheus)
	unlinkPublicKeyHandler := app.NewUnlinkPublicKeyHandler(genericTransactionProvider, logger, prometheusPrometheus)
	application := app.Application{
		GetSessionAccount:        getSessionAccountHandler,
		GetAccountPublicKeys:     getAccountPublicKeysHandler,
		GetTwitterAccountDetails: getTwitterAccountDetailsHandler,
		LoginOrRegister:          loginOrRegisterHandler,
		Logout:                   logoutHandler,
		LinkPublicKey:            linkPublicKeyHandler,
		UnlinkPublicKey:          unlinkPublicKeyHandler,
	}
	frontendFileSystem, err := frontend.NewFrontendFileSystem()
	if err != nil {
		cleanup()
		return Service{}, nil, err
	}
	server := http.NewServer(configConfig, application, logger, frontendFileSystem)
	metricsServer := http.NewMetricsServer(prometheusPrometheus, configConfig, logger)
	receivedEventPubSub := memorypubsub.NewReceivedEventPubSub()
	purplePages, err := adapters.NewPurplePages(contextContext, logger, prometheusPrometheus)
	if err != nil {
		cleanup()
		return Service{}, nil, err
	}
	relaySource := adapters.NewRelaySource(logger, purplePages)
	relayEventDownloader := adapters.NewRelayEventDownloader(contextContext, logger, prometheusPrometheus)
	downloader := app.NewDownloader(genericTransactionProvider, receivedEventPubSub, logger, prometheusPrometheus, relaySource, relayEventDownloader)
	tweetGenerator := domain.NewTweetGenerator()
	processReceivedEventHandler := app.NewProcessReceivedEventHandler(genericTransactionProvider, tweetGenerator, logger, prometheusPrometheus)
	receivedEventSubscriber := memorypubsub2.NewReceivedEventSubscriber(receivedEventPubSub, processReceivedEventHandler, logger)
	sendTweetHandler := app.NewSendTweetHandler(genericTransactionProvider, appTwitter, logger, prometheusPrometheus)
	sqliteSchema := sqlite.NewSqliteSchema()
	offsetsAdapter := sqlite.NewWatermillOffsetsAdapter()
	subscriber, err := sqlite.NewWatermillSubscriber(db, watermillAdapter, sqliteSchema, offsetsAdapter)
	if err != nil {
		cleanup()
		return Service{}, nil, err
	}
	sqliteSubscriber := sqlite.NewSubscriber(subscriber, offsetsAdapter, sqliteSchema, db)
	tweetCreatedEventSubscriber := sqlitepubsub.NewTweetCreatedEventSubscriber(sendTweetHandler, sqliteSubscriber, logger, prometheusPrometheus)
	migrations := sqlite.NewMigrations(db, sqliteSchema, offsetsAdapter)
	service := NewService(application, server, metricsServer, downloader, receivedEventSubscriber, tweetCreatedEventSubscriber, migrations)
	return service, func() {
		cleanup()
	}, nil
}

func BuildTestAdapters(contextContext context.Context, tb testing.TB) (sqlite.TestedItems, func(), error) {
	configConfig, err := newTestAdaptersConfig(tb)
	if err != nil {
		return sqlite.TestedItems{}, nil, err
	}
	logger, err := newLogger(configConfig)
	if err != nil {
		return sqlite.TestedItems{}, nil, err
	}
	db, cleanup, err := newSqliteDB(configConfig, logger)
	if err != nil {
		return sqlite.TestedItems{}, nil, err
	}
	watermillAdapter := logging.NewWatermillAdapter(logger)
	diBuildTransactionSqliteAdaptersDependencies := buildTransactionSqliteAdaptersDependencies{
		LoggerAdapter: watermillAdapter,
	}
	genericAdaptersFactoryFn := newTestAdaptersFactoryFn(diBuildTransactionSqliteAdaptersDependencies)
	genericTransactionProvider := sqlite.NewTestTransactionProvider(db, genericAdaptersFactoryFn)
	sqliteSchema := sqlite.NewSqliteSchema()
	offsetsAdapter := sqlite.NewWatermillOffsetsAdapter()
	migrations := sqlite.NewMigrations(db, sqliteSchema, offsetsAdapter)
	subscriber, err := sqlite.NewWatermillSubscriber(db, watermillAdapter, sqliteSchema, offsetsAdapter)
	if err != nil {
		cleanup()
		return sqlite.TestedItems{}, nil, err
	}
	sqliteSubscriber := sqlite.NewSubscriber(subscriber, offsetsAdapter, sqliteSchema, db)
	migrationsStorage, err := sqlite.NewMigrationsStorage(db)
	if err != nil {
		cleanup()
		return sqlite.TestedItems{}, nil, err
	}
	testedItems := sqlite.TestedItems{
		TransactionProvider: genericTransactionProvider,
		Migrations:          migrations,
		Subscriber:          sqliteSubscriber,
		MigrationsStorage:   migrationsStorage,
	}
	return testedItems, func() {
		cleanup()
	}, nil
}

func buildTransactionSqliteAdapters(db *sql.DB, tx *sql.Tx, diBuildTransactionSqliteAdaptersDependencies buildTransactionSqliteAdaptersDependencies) (app.Adapters, error) {
	accountRepository, err := sqlite.NewAccountRepository(tx)
	if err != nil {
		return app.Adapters{}, err
	}
	sessionRepository, err := sqlite.NewSessionRepository(tx)
	if err != nil {
		return app.Adapters{}, err
	}
	publicKeyRepository, err := sqlite.NewPublicKeyRepository(tx)
	if err != nil {
		return app.Adapters{}, err
	}
	processedEventRepository, err := sqlite.NewProcessedEventRepository(tx)
	if err != nil {
		return app.Adapters{}, err
	}
	userTokensRepository, err := sqlite.NewUserTokensRepository(tx)
	if err != nil {
		return app.Adapters{}, err
	}
	loggerAdapter := diBuildTransactionSqliteAdaptersDependencies.LoggerAdapter
	sqliteSchema := sqlite.NewSqliteSchema()
	publisher, err := sqlite.NewWatermillPublisher(tx, loggerAdapter, sqliteSchema)
	if err != nil {
		return app.Adapters{}, err
	}
	sqlitePublisher := sqlite.NewPublisher(publisher)
	appAdapters := app.Adapters{
		Accounts:        accountRepository,
		Sessions:        sessionRepository,
		PublicKeys:      publicKeyRepository,
		ProcessedEvents: processedEventRepository,
		UserTokens:      userTokensRepository,
		Publisher:       sqlitePublisher,
	}
	return appAdapters, nil
}

func buildTestTransactionSqliteAdapters(db *sql.DB, tx *sql.Tx, diBuildTransactionSqliteAdaptersDependencies buildTransactionSqliteAdaptersDependencies) (sqlite.TestAdapters, error) {
	sessionRepository, err := sqlite.NewSessionRepository(tx)
	if err != nil {
		return sqlite.TestAdapters{}, err
	}
	accountRepository, err := sqlite.NewAccountRepository(tx)
	if err != nil {
		return sqlite.TestAdapters{}, err
	}
	publicKeyRepository, err := sqlite.NewPublicKeyRepository(tx)
	if err != nil {
		return sqlite.TestAdapters{}, err
	}
	processedEventRepository, err := sqlite.NewProcessedEventRepository(tx)
	if err != nil {
		return sqlite.TestAdapters{}, err
	}
	userTokensRepository, err := sqlite.NewUserTokensRepository(tx)
	if err != nil {
		return sqlite.TestAdapters{}, err
	}
	loggerAdapter := diBuildTransactionSqliteAdaptersDependencies.LoggerAdapter
	sqliteSchema := sqlite.NewSqliteSchema()
	publisher, err := sqlite.NewWatermillPublisher(tx, loggerAdapter, sqliteSchema)
	if err != nil {
		return sqlite.TestAdapters{}, err
	}
	sqlitePublisher := sqlite.NewPublisher(publisher)
	testAdapters := sqlite.TestAdapters{
		SessionRepository:        sessionRepository,
		AccountRepository:        accountRepository,
		PublicKeyRepository:      publicKeyRepository,
		ProcessedEventRepository: processedEventRepository,
		UserTokensRepository:     userTokensRepository,
		Publisher:                sqlitePublisher,
	}
	return testAdapters, nil
}

// wire.go:

func newTestAdaptersConfig(tb testing.TB) (config.Config, error) {
	return config.NewConfig(fixtures.SomeString(), fixtures.SomeString(), config.EnvironmentDevelopment, logging.LevelDebug, fixtures.SomeString(), fixtures.SomeString(), fixtures.SomeFile(tb), fixtures.SomeString())
}

type buildTransactionSqliteAdaptersDependencies struct {
	LoggerAdapter watermill.LoggerAdapter
}

var downloaderSet = wire.NewSet(app.NewDownloader)

var tweetGeneratorSet = wire.NewSet(domain.NewTweetGenerator, wire.Bind(new(app.TweetGenerator), new(*domain.TweetGenerator)))
